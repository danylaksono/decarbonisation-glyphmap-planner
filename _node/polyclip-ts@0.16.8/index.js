import f from"../bignumber.js@9.1.2/index.js";import{SplayTreeSet as T}from"../splaytree-ts@1.0.2/index.js";var O=i=>()=>i,_=i=>{const t=i?(e,s)=>s.minus(e).abs().isLessThanOrEqualTo(i):O(!1);return(e,s)=>t(e,s)?0:e.comparedTo(s)};function C(i){const t=i?(e,s,n,r,u)=>e.exponentiatedBy(2).isLessThanOrEqualTo(r.minus(s).exponentiatedBy(2).plus(u.minus(n).exponentiatedBy(2)).times(i)):O(!1);return(e,s,n)=>{const r=e.x,u=e.y,o=n.x,h=n.y,l=u.minus(h).times(s.x.minus(o)).minus(r.minus(o).times(s.y.minus(h)));return t(l,r,u,o,h)?0:l.comparedTo(0)}}var $=i=>i,Y=i=>{if(i){const t=new T(_(i)),e=new T(_(i)),s=(r,u)=>u.addAndReturn(r),n=r=>({x:s(r.x,t),y:s(r.y,e)});return n({x:new f(0),y:new f(0)}),n}return $},P=i=>({set:t=>{m=P(t)},reset:()=>P(i),compare:_(i),snap:Y(i),orient:C(i)}),m=P(),d=(i,t)=>i.ll.x.isLessThanOrEqualTo(t.x)&&t.x.isLessThanOrEqualTo(i.ur.x)&&i.ll.y.isLessThanOrEqualTo(t.y)&&t.y.isLessThanOrEqualTo(i.ur.y),G=(i,t)=>{if(t.ur.x.isLessThan(i.ll.x)||i.ur.x.isLessThan(t.ll.x)||t.ur.y.isLessThan(i.ll.y)||i.ur.y.isLessThan(t.ll.y))return null;const e=i.ll.x.isLessThan(t.ll.x)?t.ll.x:i.ll.x,s=i.ur.x.isLessThan(t.ur.x)?i.ur.x:t.ur.x,n=i.ll.y.isLessThan(t.ll.y)?t.ll.y:i.ll.y,r=i.ur.y.isLessThan(t.ur.y)?i.ur.y:t.ur.y;return{ll:{x:e,y:n},ur:{x:s,y:r}}},w=(i,t)=>i.x.times(t.y).minus(i.y.times(t.x)),B=(i,t)=>i.x.times(t.x).plus(i.y.times(t.y)),R=i=>B(i,i).sqrt(),j=(i,t,e)=>{const s={x:t.x.minus(i.x),y:t.y.minus(i.y)},n={x:e.x.minus(i.x),y:e.y.minus(i.y)};return w(n,s).div(R(n)).div(R(s))},V=(i,t,e)=>{const s={x:t.x.minus(i.x),y:t.y.minus(i.y)},n={x:e.x.minus(i.x),y:e.y.minus(i.y)};return B(n,s).div(R(n)).div(R(s))},A=(i,t,e)=>t.y.isZero()?null:{x:i.x.plus(t.x.div(t.y).times(e.minus(i.y))),y:e},k=(i,t,e)=>t.x.isZero()?null:{x:e,y:i.y.plus(t.y.div(t.x).times(e.minus(i.x)))},z=(i,t,e,s)=>{if(t.x.isZero())return k(e,s,i.x);if(s.x.isZero())return k(i,t,e.x);if(t.y.isZero())return A(e,s,i.y);if(s.y.isZero())return A(i,t,e.y);const n=w(t,s);if(n.isZero())return null;const r={x:e.x.minus(i.x),y:e.y.minus(i.y)},u=w(r,t).div(n),o=w(r,s).div(n),h=i.x.plus(o.times(t.x)),l=e.x.plus(u.times(s.x)),c=i.y.plus(o.times(t.y)),a=e.y.plus(u.times(s.y)),g=h.plus(l).div(2),p=c.plus(a).div(2);return{x:g,y:p}},x=class Z{point;isLeft;segment;otherSE;consumedBy;static compare(t,e){const s=Z.comparePoints(t.point,e.point);return s!==0?s:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:L.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x.isLessThan(e.x)?-1:t.x.isGreaterThan(e.x)?1:t.y.isLessThan(e.y)?-1:t.y.isGreaterThan(e.y)?1:0}constructor(t,e){t.events===void 0?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let s=0,n=e.length;s<n;s++){const r=e[s];this.point.events.push(r),r.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const s=this.point.events[e];if(s.segment.consumedBy===void 0)for(let n=e+1;n<t;n++){const r=this.point.events[n];r.consumedBy===void 0&&s.otherSE.point.events===r.otherSE.point.events&&s.segment.consume(r.segment)}}}getAvailableLinkedEvents(){const t=[];for(let e=0,s=this.point.events.length;e<s;e++){const n=this.point.events[e];n!==this&&!n.segment.ringOut&&n.segment.isInResult()&&t.push(n)}return t}getLeftmostComparator(t){const e=new Map,s=n=>{const r=n.otherSE;e.set(n,{sine:j(this.point,t.point,r.point),cosine:V(this.point,t.point,r.point)})};return(n,r)=>{e.has(n)||s(n),e.has(r)||s(r);const{sine:u,cosine:o}=e.get(n),{sine:h,cosine:l}=e.get(r);return u.isGreaterThanOrEqualTo(0)&&h.isGreaterThanOrEqualTo(0)?o.isLessThan(l)?1:o.isGreaterThan(l)?-1:0:u.isLessThan(0)&&h.isLessThan(0)?o.isLessThan(l)?-1:o.isGreaterThan(l)?1:0:h.isLessThan(u)?-1:h.isGreaterThan(u)?1:0}}},U=class q{events;poly;_isExteriorRing;_enclosingRing;static factory(t){const e=[];for(let s=0,n=t.length;s<n;s++){const r=t[s];if(!r.isInResult()||r.ringOut)continue;let u=null,o=r.leftSE,h=r.rightSE;const l=[o],c=o.point,a=[];for(;u=o,o=h,l.push(o),o.point!==c;)for(;;){const g=o.getAvailableLinkedEvents();if(g.length===0){const y=l[0].point,b=l[l.length-1].point;throw new Error(`Unable to complete output ring starting at [${y.x}, ${y.y}]. Last matching segment found ends at [${b.x}, ${b.y}].`)}if(g.length===1){h=g[0].otherSE;break}let p=null;for(let y=0,b=a.length;y<b;y++)if(a[y].point===o.point){p=y;break}if(p!==null){const y=a.splice(p)[0],b=l.splice(y.index);b.unshift(b[0].otherSE),e.push(new q(b.reverse()));continue}a.push({index:l.length,point:o.point});const v=o.getLeftmostComparator(u);h=g.sort(v)[0].otherSE;break}e.push(new q(l))}return e}constructor(t){this.events=t;for(let e=0,s=t.length;e<s;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let l=1,c=this.events.length-1;l<c;l++){const a=this.events[l].point,g=this.events[l+1].point;m.orient(a,t,g)!==0&&(e.push(a),t=a)}if(e.length===1)return null;const s=e[0],n=e[1];m.orient(s,t,n)===0&&e.shift(),e.push(e[0]);const r=this.isExteriorRing()?1:-1,u=this.isExteriorRing()?0:e.length-1,o=this.isExteriorRing()?e.length:-1,h=[];for(let l=u;l!=o;l+=r)h.push([e[l].x.toNumber(),e[l].y.toNumber()]);return h}isExteriorRing(){if(this._isExteriorRing===void 0){const t=this.enclosingRing();this._isExteriorRing=t?!t.isExteriorRing():!0}return this._isExteriorRing}enclosingRing(){return this._enclosingRing===void 0&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let n=1,r=this.events.length;n<r;n++){const u=this.events[n];x.compare(t,u)>0&&(t=u)}let e=t.segment.prevInResult(),s=e?e.prevInResult():null;for(;;){if(!e)return null;if(!s)return e.ringOut;if(s.ringOut!==e.ringOut)return s.ringOut?.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut?.enclosingRing();e=s.prevInResult(),s=e?e.prevInResult():null}}},N=class{exteriorRing;interiorRings;constructor(i){this.exteriorRing=i,i.poly=this,this.interiorRings=[]}addInterior(i){this.interiorRings.push(i),i.poly=this}getGeom(){const i=this.exteriorRing.getGeom();if(i===null)return null;const t=[i];for(let e=0,s=this.interiorRings.length;e<s;e++){const n=this.interiorRings[e].getGeom();n!==null&&t.push(n)}return t}},D=class{rings;polys;constructor(i){this.rings=i,this.polys=this._composePolys(i)}getGeom(){const i=[];for(let t=0,e=this.polys.length;t<e;t++){const s=this.polys[t].getGeom();s!==null&&i.push(s)}return i}_composePolys(i){const t=[];for(let e=0,s=i.length;e<s;e++){const n=i[e];if(!n.poly)if(n.isExteriorRing())t.push(new N(n));else{const r=n.enclosingRing();r?.poly||t.push(new N(r)),r?.poly?.addInterior(n)}}return t}},J=class{queue;tree;segments;constructor(i,t=L.compare){this.queue=i,this.tree=new T(t),this.segments=[]}process(i){const t=i.segment,e=[];if(i.consumedBy)return i.isLeft?this.queue.delete(i.otherSE):this.tree.delete(t),e;i.isLeft&&this.tree.add(t);let s=t,n=t;do s=this.tree.lastBefore(s);while(s!=null&&s.consumedBy!=null);do n=this.tree.firstAfter(n);while(n!=null&&n.consumedBy!=null);if(i.isLeft){let r=null;if(s){const o=s.getIntersection(t);if(o!==null&&(t.isAnEndpoint(o)||(r=o),!s.isAnEndpoint(o))){const h=this._splitSafely(s,o);for(let l=0,c=h.length;l<c;l++)e.push(h[l])}}let u=null;if(n){const o=n.getIntersection(t);if(o!==null&&(t.isAnEndpoint(o)||(u=o),!n.isAnEndpoint(o))){const h=this._splitSafely(n,o);for(let l=0,c=h.length;l<c;l++)e.push(h[l])}}if(r!==null||u!==null){let o=null;r===null?o=u:u===null?o=r:o=x.comparePoints(r,u)<=0?r:u,this.queue.delete(t.rightSE),e.push(t.rightSE);const h=t.split(o);for(let l=0,c=h.length;l<c;l++)e.push(h[l])}e.length>0?(this.tree.delete(t),e.push(i)):(this.segments.push(t),t.prev=s)}else{if(s&&n){const r=s.getIntersection(n);if(r!==null){if(!s.isAnEndpoint(r)){const u=this._splitSafely(s,r);for(let o=0,h=u.length;o<h;o++)e.push(u[o])}if(!n.isAnEndpoint(r)){const u=this._splitSafely(n,r);for(let o=0,h=u.length;o<h;o++)e.push(u[o])}}}this.tree.delete(t)}return e}_splitSafely(i,t){this.tree.delete(i);const e=i.rightSE;this.queue.delete(e);const s=i.split(t);return s.push(e),i.consumedBy===void 0&&this.tree.add(i),s}},K=class{type;numMultiPolys;run(i,t,e){S.type=i;const s=[new F(t,!0)];for(let h=0,l=e.length;h<l;h++)s.push(new F(e[h],!1));if(S.numMultiPolys=s.length,S.type==="difference"){const h=s[0];let l=1;for(;l<s.length;)G(s[l].bbox,h.bbox)!==null?l++:s.splice(l,1)}if(S.type==="intersection")for(let h=0,l=s.length;h<l;h++){const c=s[h];for(let a=h+1,g=s.length;a<g;a++)if(G(c.bbox,s[a].bbox)===null)return[]}const n=new T(x.compare);for(let h=0,l=s.length;h<l;h++){const c=s[h].getSweepEvents();for(let a=0,g=c.length;a<g;a++)n.add(c[a])}const r=new J(n);let u=null;for(n.size!=0&&(u=n.first(),n.delete(u));u;){const h=r.process(u);for(let l=0,c=h.length;l<c;l++){const a=h[l];a.consumedBy===void 0&&n.add(a)}n.size!=0?(u=n.first(),n.delete(u)):u=null}m.reset();const o=U.factory(r.segments);return new D(o).getGeom()}},S=new K,E=S,Q=0,L=class I{id;leftSE;rightSE;rings;windings;ringOut;consumedBy;prev;_prevInResult;_beforeState;_afterState;_isInResult;static compare(t,e){const s=t.leftSE.point.x,n=e.leftSE.point.x,r=t.rightSE.point.x,u=e.rightSE.point.x;if(u.isLessThan(s))return 1;if(r.isLessThan(n))return-1;const o=t.leftSE.point.y,h=e.leftSE.point.y,l=t.rightSE.point.y,c=e.rightSE.point.y;if(s.isLessThan(n)){if(h.isLessThan(o)&&h.isLessThan(l))return 1;if(h.isGreaterThan(o)&&h.isGreaterThan(l))return-1;const a=t.comparePoint(e.leftSE.point);if(a<0)return 1;if(a>0)return-1;const g=e.comparePoint(t.rightSE.point);return g!==0?g:-1}if(s.isGreaterThan(n)){if(o.isLessThan(h)&&o.isLessThan(c))return-1;if(o.isGreaterThan(h)&&o.isGreaterThan(c))return 1;const a=e.comparePoint(t.leftSE.point);if(a!==0)return a;const g=t.comparePoint(e.rightSE.point);return g<0?1:g>0?-1:1}if(o.isLessThan(h))return-1;if(o.isGreaterThan(h))return 1;if(r.isLessThan(u)){const a=e.comparePoint(t.rightSE.point);if(a!==0)return a}if(r.isGreaterThan(u)){const a=t.comparePoint(e.rightSE.point);if(a<0)return 1;if(a>0)return-1}if(!r.eq(u)){const a=l.minus(o),g=r.minus(s),p=c.minus(h),v=u.minus(n);if(a.isGreaterThan(g)&&p.isLessThan(v))return 1;if(a.isLessThan(g)&&p.isGreaterThan(v))return-1}return r.isGreaterThan(u)?1:r.isLessThan(u)||l.isLessThan(c)?-1:l.isGreaterThan(c)?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,s,n){this.id=++Q,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=s,this.windings=n}static fromRing(t,e,s){let n,r,u;const o=x.comparePoints(t,e);if(o<0)n=t,r=e,u=1;else if(o>0)n=e,r=t,u=-1;else throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);const h=new x(n,!0),l=new x(r,!1);return new I(h,l,[s],[u])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t.isLessThan(e)?t:e},ur:{x:this.rightSE.point.x,y:t.isGreaterThan(e)?t:e}}}vector(){return{x:this.rightSE.point.x.minus(this.leftSE.point.x),y:this.rightSE.point.y.minus(this.leftSE.point.y)}}isAnEndpoint(t){return t.x.eq(this.leftSE.point.x)&&t.y.eq(this.leftSE.point.y)||t.x.eq(this.rightSE.point.x)&&t.y.eq(this.rightSE.point.y)}comparePoint(t){return m.orient(this.leftSE.point,t,this.rightSE.point)}getIntersection(t){const e=this.bbox(),s=t.bbox(),n=G(e,s);if(n===null)return null;const r=this.leftSE.point,u=this.rightSE.point,o=t.leftSE.point,h=t.rightSE.point,l=d(e,o)&&this.comparePoint(o)===0,c=d(s,r)&&t.comparePoint(r)===0,a=d(e,h)&&this.comparePoint(h)===0,g=d(s,u)&&t.comparePoint(u)===0;if(c&&l)return g&&!a?u:!g&&a?h:null;if(c)return a&&r.x.eq(h.x)&&r.y.eq(h.y)?null:r;if(l)return g&&u.x.eq(o.x)&&u.y.eq(o.y)?null:o;if(g&&a)return null;if(g)return u;if(a)return h;const p=z(r,this.vector(),o,t.vector());return p===null||!d(n,p)?null:m.snap(p)}split(t){const e=[],s=t.events!==void 0,n=new x(t,!0),r=new x(t,!1),u=this.rightSE;this.replaceRightSE(r),e.push(r),e.push(n);const o=new I(n,u,this.rings.slice(),this.windings.slice());return x.comparePoints(o.leftSE.point,o.rightSE.point)>0&&o.swapEvents(),x.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),s&&(n.checkForConsuming(),r.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let e=0,s=this.windings.length;e<s;e++)this.windings[e]*=-1}consume(t){let e=this,s=t;for(;e.consumedBy;)e=e.consumedBy;for(;s.consumedBy;)s=s.consumedBy;const n=I.compare(e,s);if(n!==0){if(n>0){const r=e;e=s,s=r}if(e.prev===s){const r=e;e=s,s=r}for(let r=0,u=s.rings.length;r<u;r++){const o=s.rings[r],h=s.windings[r],l=e.rings.indexOf(o);l===-1?(e.rings.push(o),e.windings.push(h)):e.windings[l]+=h}s.rings=null,s.windings=null,s.consumedBy=e,s.leftSE.consumedBy=e.leftSE,s.rightSE.consumedBy=e.rightSE}}prevInResult(){return this._prevInResult!==void 0?this._prevInResult:(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null,this._prevInResult)}beforeState(){if(this._beforeState!==void 0)return this._beforeState;if(!this.prev)this._beforeState={rings:[],windings:[],multiPolys:[]};else{const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}return this._beforeState}afterState(){if(this._afterState!==void 0)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,s=this._afterState.windings,n=this._afterState.multiPolys;for(let o=0,h=this.rings.length;o<h;o++){const l=this.rings[o],c=this.windings[o],a=e.indexOf(l);a===-1?(e.push(l),s.push(c)):s[a]+=c}const r=[],u=[];for(let o=0,h=e.length;o<h;o++){if(s[o]===0)continue;const l=e[o],c=l.poly;if(u.indexOf(c)===-1)if(l.isExterior)r.push(c);else{u.indexOf(c)===-1&&u.push(c);const a=r.indexOf(l.poly);a!==-1&&r.splice(a,1)}}for(let o=0,h=r.length;o<h;o++){const l=r[o].multiPoly;n.indexOf(l)===-1&&n.push(l)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(this._isInResult!==void 0)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(E.type){case"union":{const s=t.length===0,n=e.length===0;this._isInResult=s!==n;break}case"intersection":{let s,n;t.length<e.length?(s=t.length,n=e.length):(s=e.length,n=t.length),this._isInResult=n===E.numMultiPolys&&s<n;break}case"xor":{const s=Math.abs(t.length-e.length);this._isInResult=s%2===1;break}case"difference":{const s=n=>n.length===1&&n[0].isSubject;this._isInResult=s(t)!==s(e);break}}return this._isInResult}},M=class{poly;isExterior;segments;bbox;constructor(i,t,e){if(!Array.isArray(i)||i.length===0)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=t,this.isExterior=e,this.segments=[],typeof i[0][0]!="number"||typeof i[0][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const s=m.snap({x:new f(i[0][0]),y:new f(i[0][1])});this.bbox={ll:{x:s.x,y:s.y},ur:{x:s.x,y:s.y}};let n=s;for(let r=1,u=i.length;r<u;r++){if(typeof i[r][0]!="number"||typeof i[r][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const o=m.snap({x:new f(i[r][0]),y:new f(i[r][1])});o.x.eq(n.x)&&o.y.eq(n.y)||(this.segments.push(L.fromRing(n,o,this)),o.x.isLessThan(this.bbox.ll.x)&&(this.bbox.ll.x=o.x),o.y.isLessThan(this.bbox.ll.y)&&(this.bbox.ll.y=o.y),o.x.isGreaterThan(this.bbox.ur.x)&&(this.bbox.ur.x=o.x),o.y.isGreaterThan(this.bbox.ur.y)&&(this.bbox.ur.y=o.y),n=o)}(!s.x.eq(n.x)||!s.y.eq(n.y))&&this.segments.push(L.fromRing(n,s,this))}getSweepEvents(){const i=[];for(let t=0,e=this.segments.length;t<e;t++){const s=this.segments[t];i.push(s.leftSE),i.push(s.rightSE)}return i}},W=class{multiPoly;exteriorRing;interiorRings;bbox;constructor(i,t){if(!Array.isArray(i))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new M(i[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let e=1,s=i.length;e<s;e++){const n=new M(i[e],this,!1);n.bbox.ll.x.isLessThan(this.bbox.ll.x)&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y.isLessThan(this.bbox.ll.y)&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x.isGreaterThan(this.bbox.ur.x)&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y.isGreaterThan(this.bbox.ur.y)&&(this.bbox.ur.y=n.bbox.ur.y),this.interiorRings.push(n)}this.multiPoly=t}getSweepEvents(){const i=this.exteriorRing.getSweepEvents();for(let t=0,e=this.interiorRings.length;t<e;t++){const s=this.interiorRings[t].getSweepEvents();for(let n=0,r=s.length;n<r;n++)i.push(s[n])}return i}},F=class{isSubject;polys;bbox;constructor(i,t){if(!Array.isArray(i))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{typeof i[0][0][0]=="number"&&(i=[i])}catch{}this.polys=[],this.bbox={ll:{x:new f(Number.POSITIVE_INFINITY),y:new f(Number.POSITIVE_INFINITY)},ur:{x:new f(Number.NEGATIVE_INFINITY),y:new f(Number.NEGATIVE_INFINITY)}};for(let e=0,s=i.length;e<s;e++){const n=new W(i[e],this);n.bbox.ll.x.isLessThan(this.bbox.ll.x)&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y.isLessThan(this.bbox.ll.y)&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x.isGreaterThan(this.bbox.ur.x)&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y.isGreaterThan(this.bbox.ur.y)&&(this.bbox.ur.y=n.bbox.ur.y),this.polys.push(n)}this.isSubject=t}getSweepEvents(){const i=[];for(let t=0,e=this.polys.length;t<e;t++){const s=this.polys[t].getSweepEvents();for(let n=0,r=s.length;n<r;n++)i.push(s[n])}return i}},X=(i,...t)=>E.run("union",i,t),H=(i,...t)=>E.run("intersection",i,t),tt=(i,...t)=>E.run("xor",i,t),et=(i,...t)=>E.run("difference",i,t),st=m.set;export{et as difference,H as intersection,st as setPrecision,X as union,tt as xor};
