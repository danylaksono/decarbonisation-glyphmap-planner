import{featureCollection as O,multiPoint as x,polygon as C,point as l,lineString as w}from"../helpers@7.1.0/index.js";import{booleanPointInPolygon as u}from"../boolean-point-in-polygon@7.1.0/index.js";import{envelope as I}from"../envelope@7.1.0/index.js";import{flattenEach as M,coordReduce as N}from"../meta@7.1.0/index.js";import{featureOf as S}from"../invariant@7.1.0/index.js";function _(i){return(i>0)-(i<0)||+i}function c(i,e,t){const o=e[0]-i[0],s=e[1]-i[1],r=t[0]-e[0],n=t[1]-e[1];return _(o*n-r*s)}function R(i,e){const t=i.geometry.coordinates[0].map(n=>n[0]),o=i.geometry.coordinates[0].map(n=>n[1]),s=e.geometry.coordinates[0].map(n=>n[0]),r=e.geometry.coordinates[0].map(n=>n[1]);return Math.max.apply(null,t)===Math.max.apply(null,s)&&Math.max.apply(null,o)===Math.max.apply(null,r)&&Math.min.apply(null,t)===Math.min.apply(null,s)&&Math.min.apply(null,o)===Math.min.apply(null,r)}function m(i,e){return e.geometry.coordinates[0].every(t=>u(l(t),i))}function L(i,e){return i[0]===e[0]&&i[1]===e[1]}var f=class y{static buildId(e){return e.join(",")}constructor(e){this.id=y.buildId(e),this.coordinates=e,this.innerEdges=[],this.outerEdges=[],this.outerEdgesSorted=!1}removeInnerEdge(e){this.innerEdges=this.innerEdges.filter(t=>t.from.id!==e.from.id)}removeOuterEdge(e){this.outerEdges=this.outerEdges.filter(t=>t.to.id!==e.to.id)}addOuterEdge(e){this.outerEdges.push(e),this.outerEdgesSorted=!1}sortOuterEdges(){this.outerEdgesSorted||(this.outerEdges.sort((e,t)=>{const o=e.to,s=t.to;if(o.coordinates[0]-this.coordinates[0]>=0&&s.coordinates[0]-this.coordinates[0]<0)return 1;if(o.coordinates[0]-this.coordinates[0]<0&&s.coordinates[0]-this.coordinates[0]>=0)return-1;if(o.coordinates[0]-this.coordinates[0]===0&&s.coordinates[0]-this.coordinates[0]===0)return o.coordinates[1]-this.coordinates[1]>=0||s.coordinates[1]-this.coordinates[1]>=0?o.coordinates[1]-s.coordinates[1]:s.coordinates[1]-o.coordinates[1];const r=c(this.coordinates,o.coordinates,s.coordinates);if(r<0)return 1;if(r>0)return-1;const n=Math.pow(o.coordinates[0]-this.coordinates[0],2)+Math.pow(o.coordinates[1]-this.coordinates[1],2),h=Math.pow(s.coordinates[0]-this.coordinates[0],2)+Math.pow(s.coordinates[1]-this.coordinates[1],2);return n-h}),this.outerEdgesSorted=!0)}getOuterEdges(){return this.sortOuterEdges(),this.outerEdges}getOuterEdge(e){return this.sortOuterEdges(),this.outerEdges[e]}addInnerEdge(e){this.innerEdges.push(e)}},P=class v{getSymetric(){return this.symetric||(this.symetric=new v(this.to,this.from),this.symetric.symetric=this),this.symetric}constructor(e,t){this.from=e,this.to=t,this.next=void 0,this.label=void 0,this.symetric=void 0,this.ring=void 0,this.from.addOuterEdge(this),this.to.addInnerEdge(this)}deleteEdge(){this.from.removeOuterEdge(this),this.to.removeInnerEdge(this)}isEqual(e){return this.from.id===e.from.id&&this.to.id===e.to.id}toString(){return`Edge { ${this.from.id} -> ${this.to.id} }`}toLineString(){return w([this.from.coordinates,this.to.coordinates])}compareTo(e){return c(e.from.coordinates,e.to.coordinates,this.to.coordinates)}},E=class{constructor(){this.edges=[],this.polygon=void 0,this.envelope=void 0}push(i){this.edges.push(i),this.polygon=this.envelope=void 0}get(i){return this.edges[i]}get length(){return this.edges.length}forEach(i){this.edges.forEach(i)}map(i){return this.edges.map(i)}some(i){return this.edges.some(i)}isValid(){return!0}isHole(){const i=this.edges.reduce((s,r,n)=>(r.from.coordinates[1]>this.edges[s].from.coordinates[1]&&(s=n),s),0),e=(i===0?this.length:i)-1,t=(i+1)%this.length,o=c(this.edges[e].from.coordinates,this.edges[i].from.coordinates,this.edges[t].from.coordinates);return o===0?this.edges[e].from.coordinates[0]>this.edges[t].from.coordinates[0]:o>0}toMultiPoint(){return x(this.edges.map(i=>i.from.coordinates))}toPolygon(){if(this.polygon)return this.polygon;const i=this.edges.map(e=>e.from.coordinates);return i.push(this.edges[0].from.coordinates),this.polygon=C([i])}getEnvelope(){return this.envelope?this.envelope:this.envelope=I(this.toPolygon())}static findEdgeRingContaining(i,e){const t=i.getEnvelope();let o,s;return e.forEach(r=>{const n=r.getEnvelope();if(s&&(o=s.getEnvelope()),!R(n,t)&&m(n,t)){const h=i.map(d=>d.from.coordinates);let a;for(const d of h)r.some(g=>L(d,g.from.coordinates))||(a=d);a&&r.inside(l(a))&&(!s||m(o,n))&&(s=r)}}),s}inside(i){return u(i,this.toPolygon())}};function G(i){if(!i)throw new Error("No geojson passed");if(i.type!=="FeatureCollection"&&i.type!=="GeometryCollection"&&i.type!=="MultiLineString"&&i.type!=="LineString"&&i.type!=="Feature")throw new Error(`Invalid input type '${i.type}'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature`)}var W=class b{static fromGeoJson(e){G(e);const t=new b;return M(e,o=>{S(o,"LineString","Graph::fromGeoJson"),N(o,(s,r)=>{if(s){const n=t.getNode(s),h=t.getNode(r);t.addEdge(n,h)}return r})}),t}getNode(e){const t=f.buildId(e);let o=this.nodes[t];return o||(o=this.nodes[t]=new f(e)),o}addEdge(e,t){const o=new P(e,t),s=o.getSymetric();this.edges.push(o),this.edges.push(s)}constructor(){this.edges=[],this.nodes={}}deleteDangles(){Object.keys(this.nodes).map(e=>this.nodes[e]).forEach(e=>this._removeIfDangle(e))}_removeIfDangle(e){if(e.innerEdges.length<=1){const t=e.getOuterEdges().map(o=>o.to);this.removeNode(e),t.forEach(o=>this._removeIfDangle(o))}}deleteCutEdges(){this._computeNextCWEdges(),this._findLabeledEdgeRings(),this.edges.forEach(e=>{e.label===e.symetric.label&&(this.removeEdge(e.symetric),this.removeEdge(e))})}_computeNextCWEdges(e){typeof e>"u"?Object.keys(this.nodes).forEach(t=>this._computeNextCWEdges(this.nodes[t])):e.getOuterEdges().forEach((t,o)=>{e.getOuterEdge((o===0?e.getOuterEdges().length:o)-1).symetric.next=t})}_computeNextCCWEdges(e,t){const o=e.getOuterEdges();let s,r;for(let n=o.length-1;n>=0;--n){let h=o[n],a=h.symetric,d,g;h.label===t&&(d=h),a.label===t&&(g=a),!(!d||!g)&&(g&&(r=g),d&&(r&&(r.next=d,r=void 0),s||(s=d)))}r&&(r.next=s)}_findLabeledEdgeRings(){const e=[];let t=0;return this.edges.forEach(o=>{if(o.label>=0)return;e.push(o);let s=o;do s.label=t,s=s.next;while(!o.isEqual(s));t++}),e}getEdgeRings(){this._computeNextCWEdges(),this.edges.forEach(t=>{t.label=void 0}),this._findLabeledEdgeRings().forEach(t=>{this._findIntersectionNodes(t).forEach(o=>{this._computeNextCCWEdges(o,t.label)})});const e=[];return this.edges.forEach(t=>{t.ring||e.push(this._findEdgeRing(t))}),e}_findIntersectionNodes(e){const t=[];let o=e;do{let s=0;o.from.getOuterEdges().forEach(r=>{r.label===e.label&&++s}),s>1&&t.push(o.from),o=o.next}while(!e.isEqual(o));return t}_findEdgeRing(e){let t=e;const o=new E;do o.push(t),t.ring=o,t=t.next;while(!e.isEqual(t));return o}removeNode(e){e.getOuterEdges().forEach(t=>this.removeEdge(t)),e.innerEdges.forEach(t=>this.removeEdge(t)),delete this.nodes[e.id]}removeEdge(e){this.edges=this.edges.filter(t=>!t.isEqual(e)),e.deleteEdge()}};function p(i){const e=W.fromGeoJson(i);e.deleteDangles(),e.deleteCutEdges();const t=[],o=[];return e.getEdgeRings().filter(s=>s.isValid()).forEach(s=>{s.isHole()?t.push(s):o.push(s)}),t.forEach(s=>{E.findEdgeRingContaining(s,o)&&o.push(s)}),O(o.map(s=>s.toPolygon()))}var j=p;export{j as default,p as polygonize};
