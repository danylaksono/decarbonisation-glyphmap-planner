import{getType as m}from"../invariant@7.1.0/index.js";import{featureEach as w,geomEach as b}from"../meta@7.1.0/index.js";import{pointToLineDistance as g}from"../point-to-line-distance@7.1.0/index.js";var h=Object.defineProperty,u=Object.getOwnPropertySymbols,E=Object.prototype.hasOwnProperty,P=Object.prototype.propertyIsEnumerable,l=(r,e,t)=>e in r?h(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,i=(r,e)=>{for(var t in e||(e={}))E.call(e,t)&&l(r,t,e[t]);if(u)for(var t of u(e))P.call(e,t)&&l(r,t,e[t]);return r};function c(r,e,t={}){const f=t.units,y=t.properties||{},a=v(r);if(!a.features.length)throw new Error("points must contain features");if(!e)throw new Error("line is required");if(m(e)!=="LineString")throw new Error("line must be a LineString");let n=1/0,o=null;return w(a,p=>{const s=g(p,e,{units:f});s<n&&(n=s,o=p)}),o&&(o.properties=i(i(i({},{dist:n}),o.properties),y)),o}function v(r){const e=[];switch(r.geometry?r.geometry.type:r.type){case"GeometryCollection":return b(r,t=>{t.type==="Point"&&e.push({type:"Feature",properties:{},geometry:t})}),{type:"FeatureCollection",features:e};case"FeatureCollection":return r.features=r.features.filter(t=>t.geometry.type==="Point"),r;default:throw new Error("points must be a Point Collection")}}var O=c;export{O as default,c as nearestPointToLine};
