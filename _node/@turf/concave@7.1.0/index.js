import{distance as a}from"../distance@7.1.0/index.js";import{feature as j,featureCollection as v,isObject as h,multiLineString as b,lineString as C,geometryCollection as F}from"../helpers@7.1.0/index.js";import{featureEach as S,flattenEach as p,lineReduce as O}from"../meta@7.1.0/index.js";import{tin as P}from"../tin@7.1.0/index.js";import{clone as m}from"../clone@7.1.0/index.js";import{getType as f}from"../invariant@7.1.0/index.js";import{merge as x}from"../../topojson-client@3.1.0/index.js";import{topology as L}from"../../topojson-server@3.0.1/index.js";function k(t,o={}){if(o=o||{},!h(o))throw new Error("options is invalid");const n=o.mutate;if(f(t)!=="FeatureCollection")throw new Error("geojson must be a FeatureCollection");if(!t.features.length)throw new Error("geojson is empty");(n===!1||n===void 0)&&(t=m(t));const e=[],r=O(t,(i,s)=>z(i,s)||(e.push(i),s));return r&&e.push(r),e.length?e.length===1?e[0]:b(e.map(i=>i.coordinates)):null}function u(t){return t[0].toString()+","+t[1].toString()}function z(t,o){const n=t.geometry.coordinates,e=o.geometry.coordinates,r=u(n[0]),i=u(n[n.length-1]),s=u(e[0]),l=u(e[e.length-1]);let c;if(r===l)c=e.concat(n.slice(1));else if(s===i)c=n.concat(e.slice(1));else if(r===s)c=n.slice(1).reverse().concat(e);else if(i===l)c=n.concat(e.reverse().slice(1));else return null;return C(c)}function A(t,o={}){if(f(t)!=="FeatureCollection")throw new Error("geojson must be a FeatureCollection");if(!t.features.length)throw new Error("geojson is empty");(o.mutate===!1||o.mutate===void 0)&&(t=m(t));const n=[];p(t,r=>{n.push(r.geometry)});const e=L({geoms:F(n).geometry});return x(e,e.objects.geoms.geometries)}function B(t,o={}){if(o=o||{},!h(o))throw new Error("options is invalid");const n=o.mutate;if(f(t)!=="FeatureCollection")throw new Error("geojson must be a FeatureCollection");if(!t.features.length)throw new Error("geojson is empty");(n===!1||n===void 0)&&(t=m(t));const e=D(t);if(!e)throw new Error("geojson must be homogenous");const r=t;switch(e){case"LineString":return k(r,o);case"Polygon":return A(r,o);default:throw new Error(e+" is not supported")}}function D(t){const o={};p(t,e=>{o[e.geometry.type]=!0});const n=Object.keys(o);return n.length===1?n[0]:null}function y(t,o={}){const n=o.maxEdge||1/0,e=G(t),r=P(e);if(r.features=r.features.filter(s=>{const l=s.geometry.coordinates[0][0],c=s.geometry.coordinates[0][1],g=s.geometry.coordinates[0][2],d=a(l,c,o),w=a(c,g,o),E=a(l,g,o);return d<=n&&w<=n&&E<=n}),r.features.length<1)return null;const i=B(r);return i.coordinates.length===1&&(i.coordinates=i.coordinates[0],i.type="Polygon"),j(i)}function G(t){const o=[],n={};return S(t,e=>{if(!e.geometry)return;const r=e.geometry.coordinates.join("-");Object.prototype.hasOwnProperty.call(n,r)||(o.push(e),n[r]=!0)}),v(o)}var I=y;export{y as concave,I as default};
