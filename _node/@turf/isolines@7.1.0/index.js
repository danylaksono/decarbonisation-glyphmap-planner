import{bbox as O}from"../bbox@7.1.0/index.js";import{coordEach as E,featureEach as d}from"../meta@7.1.0/index.js";import{collectionOf as h,getCoords as u}from"../invariant@7.1.0/index.js";import{isObject as b,featureCollection as j,multiLineString as A}from"../helpers@7.1.0/index.js";import{isoContours as k}from"../../marchingsquares@1.3.3/index.js";var C=Object.defineProperty,v=Object.getOwnPropertySymbols,x=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable,y=(t,r,o)=>r in t?C(t,r,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[r]=o,w=(t,r)=>{for(var o in r||(r={}))x.call(r,o)&&y(t,o,r[o]);if(v)for(var o of v(r))z.call(r,o)&&y(t,o,r[o]);return t};function S(t,r){if(r=r||{},!b(r))throw new Error("options is invalid");var o=r.zProperty||"elevation",i=r.flip,c=r.flags;h(t,"Point","input must contain Points");for(var e=I(t,i),n=[],a=0;a<e.length;a++){for(var s=e[a],p=[],f=0;f<s.length;f++){var m=s[f];m.properties[o]?p.push(m.properties[o]):p.push(0),c===!0&&(m.properties.matrixPosition=[a,f])}n.push(p)}return n}function I(t,r){var o={};d(t,function(e){var n=u(e)[1];o[n]||(o[n]=[]),o[n].push(e)});var i=Object.keys(o).map(function(e){var n=o[e],a=n.sort(function(s,p){return u(s)[0]-u(p)[0]});return a}),c=i.sort(function(e,n){return r?u(e[0])[1]-u(n[0])[1]:u(n[0])[1]-u(e[0])[1]});return c}function P(t,r,o){if(o=o||{},!b(o))throw new Error("options is invalid");const i=o.zProperty||"elevation",c=o.commonProperties||{},e=o.breaksProperties||[];if(h(t,"Point","Input must contain Points"),!r)throw new Error("breaks is required");if(!Array.isArray(r))throw new Error("breaks must be an Array");if(!b(c))throw new Error("commonProperties must be an Object");if(!Array.isArray(e))throw new Error("breaksProperties must be an Array");const n=S(t,{zProperty:i,flip:!0}),a=q(n,r,i,c,e),s=F(a,n,t);return j(s)}function q(t,r,o,i,c){const e=[];for(let n=0;n<r.length;n++){const a=+r[n],s=w(w({},i),c[n]);s[o]=a;const p=A(k(t,a,{linearRing:!1,noFrame:!0}),s);e.push(p)}return e}function F(t,r,o){const i=O(o),c=i[2]-i[0],e=i[3]-i[1],n=i[0],a=i[1],s=r[0].length-1,p=r.length-1,f=c/s,m=e/p,g=l=>{l[0]=l[0]*f+n,l[1]=l[1]*m+a};return t.forEach(l=>{E(l,g)}),t}var H=P;export{H as default,P as isolines};
