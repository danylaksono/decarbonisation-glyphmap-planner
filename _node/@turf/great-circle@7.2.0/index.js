import{lineString as V}from"../helpers@7.2.0/index.js";import{getCoord as K}from"../invariant@7.2.0/index.js";var R=Math.PI/180,T=180/Math.PI,d=function(e,r){this.lon=e,this.lat=r,this.x=R*e,this.y=R*r};d.prototype.view=function(){return String(this.lon).slice(0,4)+","+String(this.lat).slice(0,4)},d.prototype.antipode=function(){var e=-1*this.lat,r=this.lon<0?180+this.lon:(180-this.lon)*-1;return new d(r,e)};var W=function(){this.coords=[],this.length=0};W.prototype.move_to=function(e){this.length++,this.coords.push(e)};var N=function(e){this.properties=e||{},this.geometries=[]};N.prototype.json=function(){if(this.geometries.length<=0)return{geometry:{type:"LineString",coordinates:null},type:"Feature",properties:this.properties};if(this.geometries.length===1)return{geometry:{type:"LineString",coordinates:this.geometries[0].coords},type:"Feature",properties:this.properties};for(var e=[],r=0;r<this.geometries.length;r++)e.push(this.geometries[r].coords);return{geometry:{type:"MultiLineString",coordinates:e},type:"Feature",properties:this.properties}},N.prototype.wkt=function(){for(var e="",r="LINESTRING(",t=function(n){r+=n[0]+" "+n[1]+","},o=0;o<this.geometries.length;o++){if(this.geometries[o].coords.length===0)return"LINESTRING(empty)";var s=this.geometries[o].coords;s.forEach(t),e+=r.substring(0,r.length-1)+")"}return e};var G=function(e,r,t){if(!e||e.x===void 0||e.y===void 0)throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");if(!r||r.x===void 0||r.y===void 0)throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");this.start=new d(e.x,e.y),this.end=new d(r.x,r.y),this.properties=t||{};var o=this.start.x-this.end.x,s=this.start.y-this.end.y,n=Math.pow(Math.sin(s/2),2)+Math.cos(this.start.y)*Math.cos(this.end.y)*Math.pow(Math.sin(o/2),2);if(this.g=2*Math.asin(Math.sqrt(n)),this.g===Math.PI)throw new Error("it appears "+e.view()+" and "+r.view()+" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");if(isNaN(this.g))throw new Error("could not calculate great circle between "+e+" and "+r)};G.prototype.interpolate=function(e){var r=Math.sin((1-e)*this.g)/Math.sin(this.g),t=Math.sin(e*this.g)/Math.sin(this.g),o=r*Math.cos(this.start.y)*Math.cos(this.start.x)+t*Math.cos(this.end.y)*Math.cos(this.end.x),s=r*Math.cos(this.start.y)*Math.sin(this.start.x)+t*Math.cos(this.end.y)*Math.sin(this.end.x),n=r*Math.sin(this.start.y)+t*Math.sin(this.end.y),y=T*Math.atan2(n,Math.sqrt(Math.pow(o,2)+Math.pow(s,2))),u=T*Math.atan2(s,o);return[u,y]},G.prototype.Arc=function(e,r){var t=[];if(!e||e<=2)t.push([this.start.lon,this.start.lat]),t.push([this.end.lon,this.end.lat]);else for(var o=1/(e-1),s=0;s<e;++s){var n=o*s,y=this.interpolate(n);t.push(y)}for(var u=!1,f=0,v=r&&r.offset?r.offset:10,c=180-v,l=-180+v,I=360-v,M=1;M<t.length;++M){var m=t[M-1][0],x=t[M][0],S=Math.abs(x-m);S>I&&(x>c&&m<l||m>c&&x<l)?u=!0:S>f&&(f=S)}var g=[];if(u&&f<v){var a=[];g.push(a);for(var i=0;i<t.length;++i){var L=parseFloat(t[i][0]);if(i>0&&Math.abs(L-t[i-1][0])>I){var h=parseFloat(t[i-1][0]),b=parseFloat(t[i-1][1]),p=parseFloat(t[i][0]),j=parseFloat(t[i][1]);if(h>-180&&h<l&&p===180&&i+1<t.length&&t[i-1][0]>-180&&t[i-1][0]<l){a.push([-180,t[i][1]]),i++,a.push([t[i][0],t[i][1]]);continue}else if(h>c&&h<180&&p===-180&&i+1<t.length&&t[i-1][0]>c&&t[i-1][0]<180){a.push([180,t[i][1]]),i++,a.push([t[i][0],t[i][1]]);continue}if(h<l&&p>c){var Q=h;h=p,p=Q;var U=b;b=j,j=U}if(h>c&&p<l&&(p+=360),h<=180&&p>=180&&h<p){var A=(180-h)/(p-h),P=A*j+(1-A)*b;a.push([t[i-1][0]>c?180:-180,P]),a=[],a.push([t[i-1][0]>c?-180:180,P]),g.push(a)}else a=[],g.push(a);a.push([L,t[i][1]])}else a.push([t[i][0],t[i][1]])}}else{var C=[];g.push(C);for(var w=0;w<t.length;++w)C.push([t[w][0],t[w][1]])}for(var k=new N(this.properties),E=0;E<g.length;++E){var q=new W;k.geometries.push(q);for(var J=g[E],F=0;F<J.length;++F)q.move_to(J[F])}return k};function O(e,r,t){if(t=t||{},typeof t!="object")throw new Error("options is invalid");var o=t.properties,s=t.npoints,n=t.offset;if(e=K(e),r=K(r),o=o||{},s=s||100,e[0]===r[0]&&e[1]===r[1]){const f=Array(s);return f.fill([e[0],e[1]]),V(f,o)}n=n||10;var y=new G({x:e[0],y:e[1]},{x:r[0],y:r[1]},o),u=y.Arc(s,{offset:n});return u.json()}var X=O;export{X as default,O as greatCircle};
