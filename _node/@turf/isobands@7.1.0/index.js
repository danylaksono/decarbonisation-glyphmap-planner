import{bbox as j}from"../bbox@7.1.0/index.js";import{area as C}from"../area@7.1.0/index.js";import{booleanPointInPolygon as k}from"../boolean-point-in-polygon@7.1.0/index.js";import{explode as A}from"../explode@7.1.0/index.js";import{collectionOf as b,getCoords as l}from"../invariant@7.1.0/index.js";import{isObject as m,multiPolygon as x,featureCollection as R,polygon as d}from"../helpers@7.1.0/index.js";import{featureEach as q}from"../meta@7.1.0/index.js";import{isoBands as z}from"../../marchingsquares@1.3.3/index.js";var I=Object.defineProperty,y=Object.getOwnPropertySymbols,S=Object.prototype.hasOwnProperty,B=Object.prototype.propertyIsEnumerable,P=(t,r,o)=>r in t?I(t,r,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[r]=o,v=(t,r)=>{for(var o in r||(r={}))S.call(r,o)&&P(t,o,r[o]);if(y)for(var o of y(r))B.call(r,o)&&P(t,o,r[o]);return t};function D(t,r){if(r=r||{},!m(r))throw new Error("options is invalid");var o=r.zProperty||"elevation",n=r.flip,s=r.flags;b(t,"Point","input must contain Points");for(var i=H(t,n),e=[],a=0;a<i.length;a++){for(var p=i[a],u=[],f=0;f<p.length;f++){var c=p[f];c.properties[o]?u.push(c.properties[o]):u.push(0),s===!0&&(c.properties.matrixPosition=[a,f])}e.push(u)}return e}function H(t,r){var o={};q(t,function(i){var e=l(i)[1];o[e]||(o[e]=[]),o[e].push(i)});var n=Object.keys(o).map(function(i){var e=o[i],a=e.sort(function(p,u){return l(p)[0]-l(u)[0]});return a}),s=n.sort(function(i,e){return r?l(i[0])[1]-l(e[0])[1]:l(e[0])[1]-l(i[0])[1]});return s}function w(t,r,o){if(o=o||{},!m(o))throw new Error("options is invalid");const n=o.zProperty||"elevation",s=o.commonProperties||{},i=o.breaksProperties||[];if(b(t,"Point","Input must contain Points"),!r)throw new Error("breaks is required");if(!Array.isArray(r))throw new Error("breaks is not an Array");if(!m(s))throw new Error("commonProperties is not an Object");if(!Array.isArray(i))throw new Error("breaksProperties is not an Array");const e=D(t,{zProperty:n,flip:!0});let a=T(e,r,n);a=V(a,e,t);const p=a.map((u,f)=>{if(i[f]&&!m(i[f]))throw new Error("Each mappedProperty is required to be an Object");const c=v(v({},s),i[f]);return c[n]=u[n],x(u.groupedRings,c)});return R(p)}function T(t,r,o){const n=[];for(let s=1;s<r.length;s++){const i=+r[s-1],e=+r[s],a=z(t,i,e-i),p=X(a),u=Y(p);n.push({groupedRings:u,[o]:i+"-"+e})}return n}function V(t,r,o){const n=j(o),s=n[2]-n[0],i=n[3]-n[1],e=n[0],a=n[1],p=r[0].length-1,u=r.length-1,f=s/p,c=i/u;return t.map(function(g){return g.groupedRings=g.groupedRings.map(function(E){return E.map(function(O){return O.map(h=>[h[0]*f+e,h[1]*c+a])})}),g})}function X(t){const r=t.map(function(o){return{ring:o,area:C(d([o]))}});return r.sort(function(o,n){return n.area-o.area}),r.map(function(o){return o.ring})}function Y(t){const r=t.map(n=>({lrCoordinates:n,grouped:!1})),o=[];for(;!F(r);)for(let n=0;n<r.length;n++)if(!r[n].grouped){const s=[];s.push(r[n].lrCoordinates),r[n].grouped=!0;const i=d([r[n].lrCoordinates]);for(let e=n+1;e<r.length;e++)if(!r[e].grouped){const a=d([r[e].lrCoordinates]);_(a,i)&&(s.push(r[e].lrCoordinates),r[e].grouped=!0)}o.push(s)}return o}function _(t,r){const o=A(t);for(let n=0;n<o.features.length;n++)if(!k(o.features[n],r))return!1;return!0}function F(t){for(let r=0;r<t.length;r++)if(t[r].grouped===!1)return!1;return!0}var G=w;export{G as default,w as isobands};
