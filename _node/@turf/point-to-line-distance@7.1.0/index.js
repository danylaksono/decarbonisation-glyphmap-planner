import{distance as p}from"../distance@7.1.0/index.js";import{point as y,feature as a,lineString as l,convertLength as L}from"../helpers@7.1.0/index.js";import{featureOf as c}from"../invariant@7.1.0/index.js";import{segmentEach as w}from"../meta@7.1.0/index.js";import{rhumbDistance as A}from"../rhumb-distance@7.1.0/index.js";function f(o,r,e={}){if(e.method||(e.method="geodesic"),e.units||(e.units="kilometers"),!o)throw new Error("pt is required");if(Array.isArray(o)?o=y(o):o.type==="Point"?o=a(o):c(o,"Point","point"),!r)throw new Error("line is required");Array.isArray(r)?r=l(r):r.type==="LineString"?r=a(r):c(r,"LineString","line");let t=1/0;const n=o.geometry.coordinates;return w(r,m=>{const i=m.geometry.coordinates[0],d=m.geometry.coordinates[1],s=E(n,i,d,e);s<t&&(t=s)}),L(t,"degrees",e.units)}function E(o,r,e,t){const n=[e[0]-r[0],e[1]-r[1]],m=[o[0]-r[0],o[1]-r[1]],i=h(m,n);if(i<=0)return u(o,r,{method:t.method,units:"degrees"});const d=h(n,n);if(d<=i)return u(o,e,{method:t.method,units:"degrees"});const s=i/d,g=[r[0]+s*n[0],r[1]+s*n[1]];return u(o,g,{method:t.method,units:"degrees"})}function h(o,r){return o[0]*r[0]+o[1]*r[1]}function u(o,r,e){return e.method==="planar"?A(o,r,e):p(o,r,e)}var P=f;export{P as default,f as pointToLineDistance};
