import{distance as m}from"../distance@7.2.0/index.js";import{flattenEach as K}from"../meta@7.2.0/index.js";import{point as P,degreesToRadians as L,radiansToDegrees as R}from"../helpers@7.2.0/index.js";import{getCoord as j,getCoords as N}from"../invariant@7.2.0/index.js";var S=Object.defineProperty,V=Object.defineProperties,W=Object.getOwnPropertyDescriptors,z=Object.getOwnPropertySymbols,X=Object.prototype.hasOwnProperty,Y=Object.prototype.propertyIsEnumerable,A=(r,t,o)=>t in r?S(r,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):r[t]=o,B=(r,t)=>{for(var o in t||(t={}))X.call(t,o)&&A(r,o,t[o]);if(z)for(var o of z(t))Y.call(t,o)&&A(r,o,t[o]);return r},G=(r,t)=>V(r,W(t));function H(r,t,o={}){if(!r||!t)throw new Error("lines and pt are required arguments");const e=j(t);let n=P([1/0,1/0],{dist:1/0,index:-1,multiFeatureIndex:-1,location:-1}),p=0;return K(r,function(u,d,v){const f=N(u);for(let a=0;a<f.length-1;a++){const s=P(f[a]);s.properties.dist=m(t,s,o);const b=j(s),l=P(f[a+1]);l.properties.dist=m(t,l,o);const y=j(l),O=m(s,l,o);let c,h;b[0]===e[0]&&b[1]===e[1]?[c,,h]=[b,void 0,!1]:y[0]===e[0]&&y[1]===e[1]?[c,,h]=[y,void 0,!0]:[c,,h]=Q(s.geometry.coordinates,l.geometry.coordinates,j(t));let i;c&&(i=P(c,{dist:m(t,c,o),multiFeatureIndex:v,location:p+m(s,c,o)})),i&&i.properties.dist<n.properties.dist&&(n=G(B({},i),{properties:G(B({},i.properties),{index:h?a+1:a})})),p+=O}}),n}function Z(r,t){const[o,e,n]=r,[p,u,d]=t;return o*p+e*u+n*d}function k(r,t){const[o,e,n]=r,[p,u,d]=t;return[e*d-n*u,n*p-o*d,o*u-e*p]}function J(r){return Math.sqrt(Math.pow(r[0],2)+Math.pow(r[1],2)+Math.pow(r[2],2))}function g(r,t){const o=Z(r,t)/(J(r)*J(t));return Math.acos(Math.min(Math.max(o,-1),1))}function E(r){const t=L(r[1]),o=L(r[0]);return[Math.cos(t)*Math.cos(o),Math.cos(t)*Math.sin(o),Math.sin(t)]}function w(r){const[t,o,e]=r,n=R(Math.asin(e));return[R(Math.atan2(o,t)),n]}function Q(r,t,o){const e=E(r),n=E(t),p=E(o),[u,d,v]=p,[f,a,s]=k(e,n),b=a*v-s*d,l=s*u-f*v,y=f*d-a*u,O=y*a-l*s,c=b*s-y*f,h=l*f-b*a,i=1/Math.sqrt(Math.pow(O,2)+Math.pow(c,2)+Math.pow(h,2)),x=[O*i,c*i,h*i],q=[-1*O*i,-1*c*i,-1*h*i],C=g(e,n),D=g(e,x),I=g(n,x),T=g(e,q),F=g(n,q);let M;return D<T&&D<F||I<T&&I<F?M=x:M=q,g(e,M)>C||g(n,M)>C?m(w(M),w(e))<=m(w(M),w(n))?[w(e),!0,!1]:[w(n),!1,!0]:[w(M),!1,!1]}var U=H;export{U as default,H as nearestPointOnLine};
