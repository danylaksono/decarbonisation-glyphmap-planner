import{point as L,feature as d,lineString as g,convertLength as v}from"../helpers@7.2.0/index.js";import{nearestPointOnLine as A}from"../nearest-point-on-line@7.2.0/index.js";import{featureOf as p}from"../invariant@7.2.0/index.js";import{segmentEach as E}from"../meta@7.2.0/index.js";import{rhumbDistance as a}from"../rhumb-distance@7.2.0/index.js";function l(e,r,o={}){var u,i;const f=(u=o.method)!=null?u:"geodesic",t=(i=o.units)!=null?i:"kilometers";if(!e)throw new Error("pt is required");if(Array.isArray(e)?e=L(e):e.type==="Point"?e=d(e):p(e,"Point","point"),!r)throw new Error("line is required");Array.isArray(r)?r=g(r):r.type==="LineString"?r=d(r):p(r,"LineString","line");let n=1/0;const m=e.geometry.coordinates;return E(r,s=>{if(s){const h=s.geometry.coordinates[0],w=s.geometry.coordinates[1],c=P(m,h,w,{method:f});c<n&&(n=c)}}),v(n,"degrees",t)}function P(e,r,o,u){if(u.method==="geodesic")return A(g([r,o]).geometry,e,{units:"degrees"}).properties.dist;const i=[o[0]-r[0],o[1]-r[1]],f=[e[0]-r[0],e[1]-r[1]],t=y(f,i);if(t<=0)return a(e,r,{units:"degrees"});const n=y(i,i);if(n<=t)return a(e,o,{units:"degrees"});const m=t/n,s=[r[0]+m*i[0],r[1]+m*i[1]];return a(e,s,{units:"degrees"})}function y(e,r){return e[0]*r[0]+e[1]*r[1]}var S=l;export{S as default,l as pointToLineDistance};
