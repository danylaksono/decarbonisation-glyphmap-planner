import{bearing as F}from"../bearing@7.1.0/index.js";import{distance as c}from"../distance@7.1.0/index.js";import{destination as x}from"../destination@7.1.0/index.js";import{lineIntersect as S}from"../line-intersect@7.1.0/index.js";import{flattenEach as q}from"../meta@7.1.0/index.js";import{point as g,lineString as h}from"../helpers@7.1.0/index.js";import{getCoords as D}from"../invariant@7.1.0/index.js";var L=Object.defineProperty,z=Object.defineProperties,A=Object.getOwnPropertyDescriptors,j=Object.getOwnPropertySymbols,C=Object.prototype.hasOwnProperty,M=Object.prototype.propertyIsEnumerable,I=(r,e,t)=>e in r?L(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,p=(r,e)=>{for(var t in e||(e={}))C.call(e,t)&&I(r,t,e[t]);if(j)for(var t of j(e))M.call(e,t)&&I(r,t,e[t]);return r},a=(r,e)=>z(r,A(e));function P(r,e,t={}){if(!r||!e)throw new Error("lines and pt are required arguments");let s=g([1/0,1/0],{dist:1/0,index:-1,multiFeatureIndex:-1,location:-1}),f=0;return q(r,function(w,k,m){const u=D(w);for(let n=0;n<u.length-1;n++){const o=g(u[n]);o.properties.dist=c(e,o,t);const i=g(u[n+1]);i.properties.dist=c(e,i,t);const b=c(o,i,t),y=Math.max(o.properties.dist,i.properties.dist),O=F(o,i),v=x(e,y,O+90,t),E=x(e,y,O-90,t),d=S(h([v.geometry.coordinates,E.geometry.coordinates]),h([o.geometry.coordinates,i.geometry.coordinates]));let l;d.features.length>0&&d.features[0]&&(l=a(p({},d.features[0]),{properties:{dist:c(e,d.features[0],t),multiFeatureIndex:m,location:f+c(o,d.features[0],t)}})),o.properties.dist<s.properties.dist&&(s=a(p({},o),{properties:a(p({},o.properties),{index:n,multiFeatureIndex:m,location:f})})),i.properties.dist<s.properties.dist&&(s=a(p({},i),{properties:a(p({},i.properties),{index:n+1,multiFeatureIndex:m,location:f+b})})),l&&l.properties.dist<s.properties.dist&&(s=a(p({},l),{properties:a(p({},l.properties),{index:n})})),f+=b}}),s}var _=P;export{_ as default,P as nearestPointOnLine};
