var d=class{key;left=null;right=null;constructor(e){this.key=e}},a=class extends d{constructor(e){super(e)}},c=class C extends d{value;constructor(i,t){super(i),this.value=t}replaceValue(i){const t=new C(this.key,i);return t.left=this.left,t.right=this.right,t}},g=class{size=0;modificationCount=0;splayCount=0;splay(e){const i=this.root;if(i==null)return this.compare(e,e),-1;let t=null,r=null,l=null,h=null,s=i;const u=this.compare;let n;for(;;)if(n=u(s.key,e),n>0){let o=s.left;if(o==null||(n=u(o.key,e),n>0&&(s.left=o.right,o.right=s,s=o,o=s.left,o==null)))break;t==null?r=s:t.left=s,t=s,s=o}else if(n<0){let o=s.right;if(o==null||(n=u(o.key,e),n<0&&(s.right=o.left,o.left=s,s=o,o=s.right,o==null)))break;l==null?h=s:l.right=s,l=s,s=o}else break;return l!=null&&(l.right=s.left,s.left=h),t!=null&&(t.left=s.right,s.right=r),this.root!==s&&(this.root=s,this.splayCount++),n}splayMin(e){let i=e,t=i.left;for(;t!=null;){const r=t;i.left=r.right,r.right=i,i=r,t=i.left}return i}splayMax(e){let i=e,t=i.right;for(;t!=null;){const r=t;i.right=r.left,r.left=i,i=r,t=i.right}return i}_delete(e){if(this.root==null||this.splay(e)!=0)return null;let i=this.root;const t=i,r=i.left;if(this.size--,r==null)this.root=i.right;else{const l=i.right;i=this.splayMax(r),i.right=l,this.root=i}return this.modificationCount++,t}addNewRoot(e,i){this.size++,this.modificationCount++;const t=this.root;if(t==null){this.root=e;return}i<0?(e.left=t,e.right=t.right,t.right=null):(e.right=t,e.left=t.left,t.left=null),this.root=e}_first(){const e=this.root;return e==null?null:(this.root=this.splayMin(e),this.root)}_last(){const e=this.root;return e==null?null:(this.root=this.splayMax(e),this.root)}clear(){this.root=null,this.size=0,this.modificationCount++}has(e){return this.validKey(e)&&this.splay(e)==0}defaultCompare(){return(e,i)=>e<i?-1:e>i?1:0}wrap(){return{getRoot:()=>this.root,setRoot:e=>{this.root=e},getSize:()=>this.size,getModificationCount:()=>this.modificationCount,getSplayCount:()=>this.splayCount,setSplayCount:e=>{this.splayCount=e},splay:e=>this.splay(e),has:e=>this.has(e)}}},w=class extends g{root=null;compare;validKey;constructor(e,i){super(),this.compare=e??this.defaultCompare(),this.validKey=i??(t=>t!=null&&t!=null)}delete(e){return this.validKey(e)?this._delete(e)!=null:!1}forEach(e){const i=new y(this.wrap());let t;for(;t=i.next(),!t.done;)e(t.value[1],t.value[0],this)}get(e){if(this.validKey(e)&&this.root!=null&&this.splay(e)==0)return this.root.value}hasValue(e){const i=this.splayCount,t=r=>{for(;r!=null;){if(r.value==e)return!0;if(i!=this.splayCount)throw"Concurrent modification during iteration.";if(r.right!=null&&t(r.right))return!0;r=r.left}return!1};return t(this.root)}set(e,i){const t=this.splay(e);return t==0?(this.root=this.root.replaceValue(i),this.splayCount+=1,this):(this.addNewRoot(new c(e,i),t),this)}setAll(e){e.forEach((i,t)=>{this.set(t,i)})}setIfAbsent(e,i){let t=this.splay(e);if(t==0)return this.root.value;const r=this.modificationCount,l=this.splayCount,h=i();if(r!=this.modificationCount)throw"Concurrent modification during iteration.";return l!=this.splayCount&&(t=this.splay(e)),this.addNewRoot(new c(e,h),t),h}isEmpty(){return this.root==null}isNotEmpty(){return!this.isEmpty()}firstKey(){return this.root==null?null:this._first().key}lastKey(){return this.root==null?null:this._last().key}lastKeyBefore(e){if(e==null)throw"Invalid arguments(s)";if(this.root==null)return null;if(this.splay(e)<0)return this.root.key;let i=this.root.left;if(i==null)return null;let t=i.right;for(;t!=null;)i=t,t=i.right;return i.key}firstKeyAfter(e){if(e==null)throw"Invalid arguments(s)";if(this.root==null)return null;if(this.splay(e)>0)return this.root.key;let i=this.root.right;if(i==null)return null;let t=i.left;for(;t!=null;)i=t,t=i.left;return i.key}update(e,i,t){let r=this.splay(e);if(r==0){const l=this.modificationCount,h=this.splayCount,s=i(this.root.value);if(l!=this.modificationCount)throw"Concurrent modification during iteration.";return h!=this.splayCount&&this.splay(e),this.root=this.root.replaceValue(s),this.splayCount+=1,s}if(t!=null){const l=this.modificationCount,h=this.splayCount,s=t();if(l!=this.modificationCount)throw"Concurrent modification during iteration.";return h!=this.splayCount&&(r=this.splay(e)),this.addNewRoot(new c(e,s),r),s}throw"Invalid argument (key): Key not in map."}updateAll(e){if(this.root==null)return;const i=new y(this.wrap());let t;for(;t=i.next(),!t.done;){const r=e(...t.value);i.replaceValue(r)}}keys(){return new m(this.wrap())}values(){return new S(this.wrap())}entries(){return this[Symbol.iterator]()}[Symbol.iterator](){return new y(this.wrap())}[Symbol.toStringTag]="[object Map]"},v=class f extends g{root=null;compare;validKey;constructor(i,t){super(),this.compare=i??this.defaultCompare(),this.validKey=t??(r=>r!=null&&r!=null)}delete(i){return this.validKey(i)?this._delete(i)!=null:!1}deleteAll(i){for(const t of i)this.delete(t)}forEach(i){const t=this[Symbol.iterator]();let r;for(;r=t.next(),!r.done;)i(r.value,r.value,this)}add(i){const t=this.splay(i);return t!=0&&this.addNewRoot(new a(i),t),this}addAndReturn(i){const t=this.splay(i);return t!=0&&this.addNewRoot(new a(i),t),this.root.key}addAll(i){for(const t of i)this.add(t)}isEmpty(){return this.root==null}isNotEmpty(){return this.root!=null}single(){if(this.size==0)throw"Bad state: No element";if(this.size>1)throw"Bad state: Too many element";return this.root.key}first(){if(this.size==0)throw"Bad state: No element";return this._first().key}last(){if(this.size==0)throw"Bad state: No element";return this._last().key}lastBefore(i){if(i==null)throw"Invalid arguments(s)";if(this.root==null)return null;if(this.splay(i)<0)return this.root.key;let t=this.root.left;if(t==null)return null;let r=t.right;for(;r!=null;)t=r,r=t.right;return t.key}firstAfter(i){if(i==null)throw"Invalid arguments(s)";if(this.root==null)return null;if(this.splay(i)>0)return this.root.key;let t=this.root.right;if(t==null)return null;let r=t.left;for(;r!=null;)t=r,r=t.left;return t.key}retainAll(i){const t=new f(this.compare,this.validKey),r=this.modificationCount;for(const l of i){if(r!=this.modificationCount)throw"Concurrent modification during iteration.";this.validKey(l)&&this.splay(l)==0&&t.add(this.root.key)}t.size!=this.size&&(this.root=t.root,this.size=t.size,this.modificationCount++)}lookup(i){return!this.validKey(i)||this.splay(i)!=0?null:this.root.key}intersection(i){const t=new f(this.compare,this.validKey);for(const r of this)i.has(r)&&t.add(r);return t}difference(i){const t=new f(this.compare,this.validKey);for(const r of this)i.has(r)||t.add(r);return t}union(i){const t=this.clone();return t.addAll(i),t}clone(){const i=new f(this.compare,this.validKey);return i.size=this.size,i.root=this.copyNode(this.root),i}copyNode(i){if(i==null)return null;function t(l,h){let s,u;do{if(s=l.left,u=l.right,s!=null){const n=new a(s.key);h.left=n,t(s,n)}if(u!=null){const n=new a(u.key);h.right=n,l=u,h=n}}while(u!=null)}const r=new a(i.key);return t(i,r),r}toSet(){return this.clone()}entries(){return new k(this.wrap())}keys(){return this[Symbol.iterator]()}values(){return this[Symbol.iterator]()}[Symbol.iterator](){return new m(this.wrap())}[Symbol.toStringTag]="[object Set]"},p=class{tree;path=new Array;modificationCount=null;splayCount;constructor(e){this.tree=e,this.splayCount=e.getSplayCount()}[Symbol.iterator](){return this}next(){return this.moveNext()?{done:!1,value:this.current()}:{done:!0,value:null}}current(){if(!this.path.length)return null;const e=this.path[this.path.length-1];return this.getValue(e)}rebuildPath(e){this.path.splice(0,this.path.length),this.tree.splay(e),this.path.push(this.tree.getRoot()),this.splayCount=this.tree.getSplayCount()}findLeftMostDescendent(e){for(;e!=null;)this.path.push(e),e=e.left}moveNext(){if(this.modificationCount!=this.tree.getModificationCount()){if(this.modificationCount==null){this.modificationCount=this.tree.getModificationCount();let t=this.tree.getRoot();for(;t!=null;)this.path.push(t),t=t.left;return this.path.length>0}throw"Concurrent modification during iteration."}if(!this.path.length)return!1;this.splayCount!=this.tree.getSplayCount()&&this.rebuildPath(this.path[this.path.length-1].key);let e=this.path[this.path.length-1],i=e.right;if(i!=null){for(;i!=null;)this.path.push(i),i=i.left;return!0}for(this.path.pop();this.path.length&&this.path[this.path.length-1].right===e;)e=this.path.pop();return this.path.length>0}},m=class extends p{getValue(e){return e.key}},k=class extends p{getValue(e){return[e.key,e.key]}},S=class extends p{constructor(e){super(e)}getValue(e){return e.value}},y=class extends p{constructor(e){super(e)}getValue(e){return[e.key,e.value]}replaceValue(e){if(this.modificationCount!=this.tree.getModificationCount())throw"Concurrent modification during iteration.";this.splayCount!=this.tree.getSplayCount()&&this.rebuildPath(this.path[this.path.length-1].key);const i=this.path.pop(),t=i.replaceValue(e);if(!this.path.length)this.tree.setRoot(t);else{const l=this.path[this.path.length-1];i===l.left?l.left=t:l.right=t}this.path.push(t);const r=this.tree.getSplayCount()+1;this.tree.setSplayCount(r),this.splayCount=r}};export{w as SplayTreeMap,v as SplayTreeSet};
