/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/supercluster@8.0.1/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import t from"../kdbush@4.0.2/_esm.js";const e={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},s=Math.fround||(o=new Float32Array(1),t=>(o[0]=+t,o[0]));var o;const i=3,n=5,r=6;class h{constructor(t){this.options=Object.assign(Object.create(e),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){const{log:e,minZoom:o,maxZoom:i}=this.options;e&&console.time("total time");const n=`prepare ${t.length} points`;e&&console.time(n),this.points=t;const r=[];for(let e=0;e<t.length;e++){const o=t[e];if(!o.geometry)continue;const[i,n]=o.geometry.coordinates,h=s(u(i)),a=s(p(n));r.push(h,a,1/0,e,-1,1),this.options.reduce&&r.push(0)}let h=this.trees[i+1]=this._createTree(r);e&&console.timeEnd(n);for(let t=i;t>=o;t--){const s=+Date.now();h=this.trees[t]=this._createTree(this._cluster(h,t)),e&&console.log("z%d: %d clusters in %dms",t,h.numItems,+Date.now()-s)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let s=((t[0]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,t[1]));let r=180===t[2]?180:((t[2]+180)%360+360)%360-180;const h=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)s=-180,r=180;else if(s>r){const t=this.getClusters([s,o,180,h],e),i=this.getClusters([-180,o,r,h],e);return t.concat(i)}const c=this.trees[this._limitZoom(e)],l=c.range(u(s),p(h),u(r),p(o)),d=c.data,m=[];for(const t of l){const e=this.stride*t;m.push(d[e+n]>1?a(d,e,this.clusterProps):this.points[d[e+i]])}return m}getChildren(t){const e=this._getOriginId(t),s=this._getOriginZoom(t),o="No cluster with the specified id.",r=this.trees[s];if(!r)throw new Error(o);const h=r.data;if(e*this.stride>=h.length)throw new Error(o);const c=this.options.radius/(this.options.extent*Math.pow(2,s-1)),u=h[e*this.stride],p=h[e*this.stride+1],l=r.within(u,p,c),d=[];for(const e of l){const s=e*this.stride;h[s+4]===t&&d.push(h[s+n]>1?a(h,s,this.clusterProps):this.points[h[s+i]])}if(0===d.length)throw new Error(o);return d}getLeaves(t,e,s){e=e||10,s=s||0;const o=[];return this._appendLeaves(o,t,e,s,0),o}getTile(t,e,s){const o=this.trees[this._limitZoom(t)],i=Math.pow(2,t),{extent:n,radius:r}=this.options,h=r/n,a=(s-h)/i,c=(s+1+h)/i,u={features:[]};return this._addTileFeatures(o.range((e-h)/i,a,(e+1+h)/i,c),o.data,e,s,i,u),0===e&&this._addTileFeatures(o.range(1-h/i,a,1,c),o.data,i,s,i,u),e===i-1&&this._addTileFeatures(o.range(0,a,h/i,c),o.data,-1,s,i,u),u.features.length?u:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const s=this.getChildren(t);if(e++,1!==s.length)break;t=s[0].properties.cluster_id}return e}_appendLeaves(t,e,s,o,i){const n=this.getChildren(e);for(const e of n){const n=e.properties;if(n&&n.cluster?i+n.point_count<=o?i+=n.point_count:i=this._appendLeaves(t,n.cluster_id,s,o,i):i<o?i++:t.push(e),t.length===s)break}return i}_createTree(e){const s=new t(e.length/this.stride|0,this.options.nodeSize,Float32Array);for(let t=0;t<e.length;t+=this.stride)s.add(e[t],e[t+1]);return s.finish(),s.data=e,s}_addTileFeatures(t,e,s,o,r,h){for(const a of t){const t=a*this.stride,l=e[t+n]>1;let d,m,g;if(l)d=c(e,t,this.clusterProps),m=e[t],g=e[t+1];else{const s=this.points[e[t+i]];d=s.properties;const[o,n]=s.geometry.coordinates;m=u(o),g=p(n)}const f={type:1,geometry:[[Math.round(this.options.extent*(m*r-s)),Math.round(this.options.extent*(g*r-o))]],tags:d};let _;_=l||this.options.generateId?e[t+i]:this.points[e[t+i]].id,void 0!==_&&(f.id=_),h.features.push(f)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const{radius:s,extent:o,reduce:i,minPoints:r}=this.options,h=s/(o*Math.pow(2,e)),a=t.data,c=[],u=this.stride;for(let s=0;s<a.length;s+=u){if(a[s+2]<=e)continue;a[s+2]=e;const o=a[s],p=a[s+1],l=t.within(a[s],a[s+1],h),d=a[s+n];let m=d;for(const t of l){const s=t*u;a[s+2]>e&&(m+=a[s+n])}if(m>d&&m>=r){let t,r=o*d,h=p*d,g=-1;const f=((s/u|0)<<5)+(e+1)+this.points.length;for(const o of l){const c=o*u;if(a[c+2]<=e)continue;a[c+2]=e;const p=a[c+n];r+=a[c]*p,h+=a[c+1]*p,a[c+4]=f,i&&(t||(t=this._map(a,s,!0),g=this.clusterProps.length,this.clusterProps.push(t)),i(t,this._map(a,c)))}a[s+4]=f,c.push(r/m,h/m,1/0,f,-1,m),i&&c.push(g)}else{for(let t=0;t<u;t++)c.push(a[s+t]);if(m>1)for(const t of l){const s=t*u;if(!(a[s+2]<=e)){a[s+2]=e;for(let t=0;t<u;t++)c.push(a[s+t])}}}}return c}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e,s){if(t[e+n]>1){const o=this.clusterProps[t[e+r]];return s?Object.assign({},o):o}const o=this.points[t[e+i]].properties,h=this.options.map(o);return s&&h===o?Object.assign({},h):h}}function a(t,e,s){return{type:"Feature",id:t[e+i],properties:c(t,e,s),geometry:{type:"Point",coordinates:[(o=t[e],360*(o-.5)),l(t[e+1])]}};var o}function c(t,e,s){const o=t[e+n],h=o>=1e4?`${Math.round(o/1e3)}k`:o>=1e3?Math.round(o/100)/10+"k":o,a=t[e+r],c=-1===a?{}:Object.assign({},s[a]);return Object.assign(c,{cluster:!0,cluster_id:t[e+i],point_count:o,point_count_abbreviated:h})}function u(t){return t/360+.5}function p(t){const e=Math.sin(t*Math.PI/180),s=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return s<0?0:s>1?1:s}function l(t){const e=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}export{h as default};
